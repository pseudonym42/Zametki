Standard CPython's garbage collector has two components, the reference counting collector and the generational cyclic garbage collector, known as GC module.
The reference counting algorithm is very efficient and straightforward, but it cannot detect reference cycles. That is why Python has a GC module, that deals with reference cycles. Reference cycles happen when object stores a reference to itself, e.g.:

```Python
lst = []
lst.append(lst)
```

Reference cycles can only occur in container objects (i.e., in objects which can contain other objects), such as lists, dictionaries, classes, tuples.

Most of the garbage collection is done by reference counting algorithm, which we cannot tune at all. Reference counting is a simple technique in which objects are de-allocated when there is no reference to them in a program. Every variable in Python is a reference to an object located on heap and not the actual value itself. To keep track of references - every object (even integer) has an extra field called reference count that is increased or decreased when a pointer to the object is copied or deleted. For example, the reference count increases: assignment operator, argument passing, appending an object to a list (object's reference count will be increased). If reference counting field reaches zero, CPython automatically calls the object-specific de-allocation function. If an object contains references to other objects, then their reference count is decremented too. Thus other objects may be de-allocated in turn. For example, when a list is deleted the reference count of all its items is decreased. Variables, which declared outside of functions, classes, and blocks are called globals. Usually, such variables live until the end of the Python's process. Thus, the reference count of objects, which are referred by globals, never drops to 0.

Unlike the reference counting, the cyclic GC does not work in real-time and runs periodically. To reduce the frequency of GC calls and pauses CPython uses various heuristics. As was said above reference cycles can only occur in container objects. The GC classifies container objects into three generations. Every new object starts in the first generation. If an object survives a garbage collection round, it moves to the older (higher) generation. Lower generations are collected more often than higher. Because most of the newly created objects die young, it improves GC performance and reduces the GC pause time. In order to decide when to run, each generation has an individual counter and threshold. The counter stores the number of object allocations minus de-allocations since the last collection. Every time you allocate a new container object, CPython checks whenever the counter of the first generation exceeds the threshold value. If so Python initiates the —Åollection process. If we have two or more generations that currently exceed the threshold, GC chooses the oldest one. That is because oldest generations are also collecting all previous (younger) generations. To reduce performance degradation for long-living objects the third generation has additional requirements in order to be chosen. The standard threshold values are set to (700, 10, 10) respectively, but you can always check them using `gc.get_threshold` function
